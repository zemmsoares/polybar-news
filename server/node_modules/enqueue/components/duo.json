{
  "source.js": {
    "id": "source.js",
    "type": "js",
    "mtime": 1409544816225,
    "src": "require('matthewmueller/better-batch')\n",
    "deps": {
      "matthewmueller/better-batch": "components/matthewmueller-better-batch@0.0.1/index.js"
    },
    "entry": true
  },
  "components/matthewmueller-better-batch@0.0.1/index.js": {
    "id": "components/matthewmueller-better-batch@0.0.1/index.js",
    "type": "js",
    "mtime": 1409543370000,
    "src": "/**\n * Module Dependencies\n */\n\nvar enqueue = require('enqueue');\nvar wrap = require('wrap-fn');\nvar once = require('once');\nvar noop = function(){};\nvar slice = [].slice;\n\n/**\n * Export `Batch`\n */\n\nmodule.exports = Batch;\n\n/**\n * Initialize `Batch`\n *\n * @param {Function or Array or Batch} fn (optional)\n */\n\nfunction Batch(fn) {\n  if (!(this instanceof Batch)) return new Batch(fn);\n  this.n = Infinity;\n  this.throws(true);\n  this.length = 0;\n  this.fns = [];\n\n  if (fn) this.push(fn);\n}\n\n/**\n * Set concurrency to `n`.\n *\n * @param {Number} n\n * @return {Batch}\n * @api public\n */\n\nBatch.prototype.concurrency = function(n){\n  this.n = n;\n  return this;\n};\n\n/**\n * Set whether Batch will or will not throw up.\n *\n * @param  {Boolean} throws\n * @return {Batch}\n * @api public\n */\n\nBatch.prototype.throws = function(throws) {\n  this.e = !!throws;\n  return this;\n};\n\n/**\n * Push a new function\n *\n * @param {Function|Generator} fn\n * @return {Batch}\n * @api public\n */\n\nBatch.prototype.push = function (fn) {\n  if (fn instanceof Batch) {\n    return this.use(fn.fns);\n  }\n\n  if (fn instanceof Array) {\n    for (var i = 0, f; f = fn[i++];) this.use(f);\n    return this;\n  }\n\n  this.fns.push(fn);\n  this.length = this.fns.length;\n  return this;\n};\n\n/**\n * Execute all queued functions in parallel,\n * executing `cb(err, results)`.\n *\n * @param {Mixed, ...} args\n * @param {Functio} fn (optional)\n * @return {Batch}\n * @api public\n */\n\nBatch.prototype.end = function() {\n  var args = slice.call(arguments);\n  var last = args[args.length - 1];\n  var done = 'function' == typeof last && last;\n  var len = this.length;\n  var throws = this.e;\n  var fns = this.fns;\n  var pending = len;\n  var results = [];\n  var errors = [];\n  var ctx = this;\n\n  // update args\n  var args = done\n    ? slice.call(arguments, 0, arguments.length - 1)\n    : slice.call(arguments);\n\n  // only call done once\n  done = once(done || noop);\n\n  // empty\n  if (!len) return done(null, results);\n\n  // process\n  function next(i) {\n    return function(err, res) {\n      if (err && throws) return done(err);\n\n      results[i] = res;\n      errors[i] = err;\n\n      if (--pending) return;\n      else if (!throws) done(errors, results);\n      else done(null, results);\n    }\n  }\n\n  // queue calls with `n` concurrency\n  var call = enqueue(function(fn, i) {\n    wrap(fn, next(i)).apply(ctx, args);\n  }, this.n);\n\n  // call the fns in parallel\n  for (var i = 0, fn; fn = fns[i]; i++) call(fn, i);\n\n  return this;\n};\n",
    "deps": {
      "wrap-fn": "components/matthewmueller-wrap-fn@0.0.1/index.js"
    }
  },
  "components/matthewmueller-wrap-fn@0.0.1/index.js": {
    "id": "components/matthewmueller-wrap-fn@0.0.1/index.js",
    "type": "js",
    "mtime": 1409536796000,
    "src": "/**\n * Module Dependencies\n */\n\nvar slice = [].slice;\nvar co = require('co');\nvar noop = function(){};\n\n/**\n * Export `wrap-fn`\n */\n\nmodule.exports = wrap;\n\n/**\n * Wrap a function to support\n * sync, async, and gen functions.\n *\n * @param {Function} fn\n * @param {Function} done\n * @return {Function}\n * @api public\n */\n\nfunction wrap(fn, done) {\n  done = done || noop;\n\n  return function() {\n    var args = slice.call(arguments);\n    var ctx = this;\n\n    if (!fn) {\n      // done\n      return done.apply(ctx, [null].concat(args));\n    } else if (fn.length > args.length) {\n      // async\n      fn.apply(ctx, args.concat(done));\n    } else if (generator(fn)) {\n      // generator\n      co(fn).apply(ctx, args.concat(done));\n    } else {\n      // sync\n      var ret = fn.apply(ctx, args);\n      ret instanceof Error ? done(ret) : done();\n    }\n  }\n}\n\n/**\n * Is `value` a generator?\n *\n * @param {Mixed} value\n * @return {Boolean}\n * @api private\n */\n\nfunction generator(value) {\n  return value\n    && value.constructor\n    && 'GeneratorFunction' == value.constructor.name;\n}\n",
    "deps": {
      "co": "components/visionmedia-co@3.1.0/index.js"
    }
  },
  "components/visionmedia-co@3.1.0/index.js": {
    "id": "components/visionmedia-co@3.1.0/index.js",
    "type": "js",
    "mtime": 1404182887000,
    "src": "\n/**\n * slice() reference.\n */\n\nvar slice = Array.prototype.slice;\n\n/**\n * Expose `co`.\n */\n\nmodule.exports = co;\n\n/**\n * Wrap the given generator `fn` and\n * return a thunk.\n *\n * @param {Function} fn\n * @return {Function}\n * @api public\n */\n\nfunction co(fn) {\n  var isGenFun = isGeneratorFunction(fn);\n\n  return function (done) {\n    var ctx = this;\n\n    // in toThunk() below we invoke co()\n    // with a generator, so optimize for\n    // this case\n    var gen = fn;\n\n    // we only need to parse the arguments\n    // if gen is a generator function.\n    if (isGenFun) {\n      var args = slice.call(arguments), len = args.length;\n      var hasCallback = len && 'function' == typeof args[len - 1];\n      done = hasCallback ? args.pop() : error;\n      gen = fn.apply(this, args);\n    } else {\n      done = done || error;\n    }\n\n    next();\n\n    // #92\n    // wrap the callback in a setImmediate\n    // so that any of its errors aren't caught by `co`\n    function exit(err, res) {\n      setImmediate(function(){\n        done.call(ctx, err, res);\n      });\n    }\n\n    function next(err, res) {\n      var ret;\n\n      // multiple args\n      if (arguments.length > 2) res = slice.call(arguments, 1);\n\n      // error\n      if (err) {\n        try {\n          ret = gen.throw(err);\n        } catch (e) {\n          return exit(e);\n        }\n      }\n\n      // ok\n      if (!err) {\n        try {\n          ret = gen.next(res);\n        } catch (e) {\n          return exit(e);\n        }\n      }\n\n      // done\n      if (ret.done) return exit(null, ret.value);\n\n      // normalize\n      ret.value = toThunk(ret.value, ctx);\n\n      // run\n      if ('function' == typeof ret.value) {\n        var called = false;\n        try {\n          ret.value.call(ctx, function(){\n            if (called) return;\n            called = true;\n            next.apply(ctx, arguments);\n          });\n        } catch (e) {\n          setImmediate(function(){\n            if (called) return;\n            called = true;\n            next(e);\n          });\n        }\n        return;\n      }\n\n      // invalid\n      next(new TypeError('You may only yield a function, promise, generator, array, or object, '\n        + 'but the following was passed: \"' + String(ret.value) + '\"'));\n    }\n  }\n}\n\n/**\n * Convert `obj` into a normalized thunk.\n *\n * @param {Mixed} obj\n * @param {Mixed} ctx\n * @return {Function}\n * @api private\n */\n\nfunction toThunk(obj, ctx) {\n\n  if (isGeneratorFunction(obj)) {\n    return co(obj.call(ctx));\n  }\n\n  if (isGenerator(obj)) {\n    return co(obj);\n  }\n\n  if (isPromise(obj)) {\n    return promiseToThunk(obj);\n  }\n\n  if ('function' == typeof obj) {\n    return obj;\n  }\n\n  if (isObject(obj) || Array.isArray(obj)) {\n    return objectToThunk.call(ctx, obj);\n  }\n\n  return obj;\n}\n\n/**\n * Convert an object of yieldables to a thunk.\n *\n * @param {Object} obj\n * @return {Function}\n * @api private\n */\n\nfunction objectToThunk(obj){\n  var ctx = this;\n  var isArray = Array.isArray(obj);\n\n  return function(done){\n    var keys = Object.keys(obj);\n    var pending = keys.length;\n    var results = isArray\n      ? new Array(pending) // predefine the array length\n      : new obj.constructor();\n    var finished;\n\n    if (!pending) {\n      setImmediate(function(){\n        done(null, results)\n      });\n      return;\n    }\n\n    // prepopulate object keys to preserve key ordering\n    if (!isArray) {\n      for (var i = 0; i < pending; i++) {\n        results[keys[i]] = undefined;\n      }\n    }\n\n    for (var i = 0; i < keys.length; i++) {\n      run(obj[keys[i]], keys[i]);\n    }\n\n    function run(fn, key) {\n      if (finished) return;\n      try {\n        fn = toThunk(fn, ctx);\n\n        if ('function' != typeof fn) {\n          results[key] = fn;\n          return --pending || done(null, results);\n        }\n\n        fn.call(ctx, function(err, res){\n          if (finished) return;\n\n          if (err) {\n            finished = true;\n            return done(err);\n          }\n\n          results[key] = res;\n          --pending || done(null, results);\n        });\n      } catch (err) {\n        finished = true;\n        done(err);\n      }\n    }\n  }\n}\n\n/**\n * Convert `promise` to a thunk.\n *\n * @param {Object} promise\n * @return {Function}\n * @api private\n */\n\nfunction promiseToThunk(promise) {\n  return function(fn){\n    promise.then(function(res) {\n      fn(null, res);\n    }, fn);\n  }\n}\n\n/**\n * Check if `obj` is a promise.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isPromise(obj) {\n  return obj && 'function' == typeof obj.then;\n}\n\n/**\n * Check if `obj` is a generator.\n *\n * @param {Mixed} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isGenerator(obj) {\n  return obj && 'function' == typeof obj.next && 'function' == typeof obj.throw;\n}\n\n/**\n * Check if `obj` is a generator function.\n *\n * @param {Mixed} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isGeneratorFunction(obj) {\n  return obj && obj.constructor && 'GeneratorFunction' == obj.constructor.name;\n}\n\n/**\n * Check for plain object.\n *\n * @param {Mixed} val\n * @return {Boolean}\n * @api private\n */\n\nfunction isObject(val) {\n  return val && Object == val.constructor;\n}\n\n/**\n * Throw `err` in a new stack.\n *\n * This is used when co() is invoked\n * without supplying a callback, which\n * should only be for demonstrational\n * purposes.\n *\n * @param {Error} err\n * @api private\n */\n\nfunction error(err) {\n  if (!err) return;\n  setImmediate(function(){\n    throw err;\n  });\n}\n",
    "deps": {}
  }
}